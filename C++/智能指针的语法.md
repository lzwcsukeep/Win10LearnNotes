### 创建智能指针：

#include <memory>

`std::shared_ptr<T> ptr(new T); `// 创建一个智能指针，管理动态分配的类型为 T 的对象
`std::shared_ptr<T> ptr = std::make_shared<T>(args...);` // 使用 make_shared 创建智能指针，并初始化对象,make_shared会调用类型T的构造，并传递参数args给构造函数

注： 上述两种方式创建的对象都是在堆内存上分配。

### 常见用法：

1. **创建智能指针并管理动态分配的内存**：

```cpp
std::shared_ptr<int> ptr(new int(42));
```

2. **使用 `make_shared` 创建智能指针**：

```cpp
std::shared_ptr<int> ptr = std::make_shared<int>(42);
```

3. **访问所管理的对象**：

```cpp
std::cout << "Value of ptr: " << *ptr << std::endl;
```

4. **修改所管理的对象**：

```cpp
*ptr = 100;
```

5. **创建另一个指针指向相同的对象**：

```cpp
std::shared_ptr<int> ptr2 = ptr;
```

6. **获取当前指向同一对象的指针数量**：

```cpp
std::cout << "Number of pointers: " << ptr.use_count() << std::endl;
```

7. **释放所管理的内存**：

```cpp
ptr.reset(); // 释放内存并将指针重置为空
```

8. **获取指向所管理对象的裸指针**：

```cpp
T* rawPtr = ptr.get();
```

### 使用了智能指针还是可能发生内存泄漏

**循环引用**：当多个 `std::shared_ptr` 相互引用时，形成循环引用，这可能导致对象永远不会被销毁，从而造成内存泄漏。

下面代码存在循环引用造成内存泄漏。

```cpp
#include <memory>
#include <iostream>
class B; // 提前声明类 B

class A {
public:
    std::shared_ptr<B> ptrB; // A 持有 B 的 shared_ptr

    A() {
        std::cout << "A constructor" << std::endl;
    }

    ~A() {
        std::cout << "A destructor" << std::endl;
    }
};

class B {
public:
    std::shared_ptr<A> ptrA; // B 持有 A 的 shared_ptr

    B() {
        std::cout << "B constructor" << std::endl;
    }

    ~B() {
        std::cout << "B destructor" << std::endl;
    }
};

int main() {
    std::shared_ptr<A> a(new A());
    std::shared_ptr<B> b(new B());

    // 互相持有对方的 shared_ptr
    a->ptrB = b;
    b->ptrA = a;

    return 0;
}
```
