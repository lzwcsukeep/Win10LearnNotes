### JAVA 运行时栈帧结构

JAVA虚拟机规范实在是定义了太多东西，搞得人脑袋大，作为计算机最直接的功能就是计算，其他的结构应该是用来辅助计算的。从这个角度来讲，最直接的结构就是运行时栈帧了，它直接和一个具体的方法执行有关。

那么就来看看运行时栈帧是怎么工作的。

运行时栈帧（Stack Frame）是JAVA 虚拟机栈(JVM Stack)的栈元素，JAVA虚拟机栈是JAVA运行时数据区(Java Run-time Area )的一部分。你看，一上来就又带出了两个概念--**Java 虚拟机栈**和**Java 运行时数据区** (绝望)。

JAVA每一个方法的执行，对应着一个栈帧的创建并在JVM Stack 栈顶入栈，方法的执行结束也意味着JVM Stack 栈顶处栈帧的出栈。

#### 栈帧的内部结构

- 局部变量表(Local Variables Table)

> 局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java 程序被编译为Class 文件时，就在方法的Code 属性的max_locals 数据项中确定了该方法所需分配的局部变量表的最大容量

- 操作数栈(Operand Stack)

> 方法执行需要操作数据，运行过程需要的数据以及中间产生的数据都会借助操作数栈来保存，操作数栈也被称作操作栈，是一个后入先出的结构。同局部变量一样，操作数栈的最大深度也在编译时被写入Code 属性的max_stacks中。当一个方法开始执行的时候，这个方法的操作数栈是空的。

- 动态连接（Dynamic Linking）

> 每个栈帧都包含了一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。动态连接是啥？其实就是运行期间将符号引用转化为直接引用。

- 方法返回地址
- 附加信息

#### 基于栈的解释执行

定义如下方法

```java
public int calc() {
    int a = 100 ;
    int b = 200 ;
    int c = 300 ;
    return (a+b)*c ;
}
```

用javap查看编译后对应的字节码指令

```java
public int calc();
    code:
        Stack=2, Locals=4, Args_size=1
         0:        bipush   100
         2:        istore_1
         3:        sipush   200
         6:        istore_2
         7:        sipush   300
        10:        istore_3 
        11:        iload_1
        12:        iload_2
        13：        iadd
        14:        iload_3
        15:        imul
        16:        ireturn
```

javap提示需要深度为2的操作数栈和4个变量槽的局部变量空间，根据这些画出栈帧执行时对应当前指令，局部变量表，操作数栈的变化情况。

图片见深入理解JVM 333页

---------------------------------------------------------------------------------------------------------------------------------------------------------

栈帧中局部变量表的大小和操作数栈的深度在编译阶段就已经确定了。

这里注意，**操作数栈也是每一个栈帧就有一个**，而不是整个线程共用一个操作数栈。也就是说，每个方法都有自己的操作数栈

> jvms11 原文 ：
> 
> Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the run-
> time constant pool (§2.5.5) of the class of the current method.