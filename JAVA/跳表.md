#### 跳表(SkipList)

**什么是跳表？**

计算机科学中，跳表是一种概率性的数据结构，在含n个元素的有序序列中允许$O(\log n)$ 复杂度的查找和插入。它可以获得排序数组的最佳特征（用于搜索），同时保持允许插入的类似链表的结构，这在数组中是不可能的

跳表是一种基于链表的改进型数据结构，用层次化的链表实现快速的$O(\log n)$ 插入和$O(\log n)$的查找操作。

一个跳表有很多层，最底层是正常的包含所有n个元素的一个链表。每一个较高层就像是低层的快速通道。第`i` 层的每个元素都以概率`p`  （通常取1/2或1/4）上升到第`i+1` 层。也就是说如果概率`p = 1/2 `, 第 `i`  层有8个元素，那么就会从中选出4个元素上升到 `i+1` 层。平均来看每一个元素会出现在$1/(1-p)$ 个链表中，并且最高的元素（通常是一个特殊的头节点）会出现在所有的链表中。具有n个元素的序列，其跳表会包含$\lceil \log _{1/p} n\rceil$ 个链表。



**跳表的构建** 

如下图：一个含有10个元素的跳表结构如下

最底层是一个正常的含所有元素的链表，固定概率$p=1/2$ ，那么就从最底层选5个元素进入第二层，构成第二层的链表，同理从第二层中选择3个元素进入第三层构成第三层的链表。最后从第三层中选择一个进入第四层。这个跳表每一层链表都有一个头节点。整个跳表具有$\lceil \log _2 10\rceil = 4$ 个链表，也就是有四层。并且部分元素会出现在多个链表中。高层的元素不仅有向前的指针，还有指向下层的指针。

![skiplist](C:\Users\lzw\Desktop\img_src\Skip_list.svg)

 

**查找操作**

查询一个目标元素会从最高层的链表(也是最稀疏的链表)的头节点开始水平的进行，直到当前元素大于或者等于目标元素。如果当前元素等于目标元素那么就找到了目标元素。如果当前元素大于目标或者搜索到达了链表尾端，那么就退回到之前的元素，并且垂直往下到达更低层的链表继续上述搜索。在每一层链表上进行搜索的步数不会超过$1/p$ (你可以选定一个元素进行搜索试试)。 因此总的步数不超过 $\frac{1}{p} \log _{1/p} n$ 。因为p是常数，因此搜索一个元素的时间复杂度是$O(\log n)$



**插入和删除**

插入和删除操作类似于链表的插入和删除操作，不过对于”层次高“的元素需要在多个链表中插入和删除。

![Skip_list_add_element-en](C:\Users\lzw\Desktop\img_src\Skip_list_add_element-en.gif)

**带索引的跳表（实现$O(\log n)$随机访问）**

如上所述，跳表可以在一个有序序列中实现$O(\log n)$ 的快速插入和删除元素操作。但是对于给定位置的随机访问操作（比如返回第500个元素）仍然是较慢的$O(n)$ 。然而只需要一个小小的修改，就可以将随机访问的时间复杂度提升到$O(\log n)$ 。

对于每一个指针，同时保存指针的宽度。指针的宽度定义为跨越的最底层的指针数目，直观来讲，就是记录了该指针实际跳跃的底层元素的个数。

比如，下面就是上面例子的指针宽度值

```tex
   1                               10
 o---> o---------------------------------------------------------> o    Top level
   1           3              2                    5
 o---> o---------------> o---------> o---------------------------> o    Level 3
   1        2        1        2              3              2
 o---> o---------> o---> o---------> o---------------> o---------> o    Level 2
   1     1     1     1     1     1     1     1     1     1     1 
 o---> o---> o---> o---> o---> o---> o---> o---> o---> o---> o---> o    Bottom level
Head  1st   2nd   3rd   4th   5th   6th   7th   8th   9th   10th  NIL
      Node  Node  Node  Node  Node  Node  Node  Node  Node  Node
```

最底层的指针宽度定义为1

注意到更高层的指针宽度等于它下面指针宽度的和。(宽度为10的指针为它下面宽度为3，2，5的指针宽度之和)。

因此，每一层的指针宽度和都相等(10 + 1 = 1 + 3 + 2 + 5 = 1 + 2 + 1 + 2 + 3 + 2)。

对跳表进行索引之后找到第i个元素，需要在遍历跳表的同时计算每一个被遍历的指针的宽度，如果接下来的指针宽度太大就需要下降一层。

例如，要查找第五个位置（节点 5）的节点，请在顶层遍历宽度为 1 的指针。现在还需要四步，因为这个级别的下一个宽度是 10，这太大了，所以降一级。遍历一个宽度为 3 的链接。由于宽度为 2 的另一步会太远，请下降到最底层。现在遍历宽度为1的最后一环，达到目标运行总数5（1+3+1）。

伪代码如下：

```java
function lookupByPositionIndex(i)
    node ← head
    i ← i + 1                           # don't count the head as a step
    for level from top to bottom do
        while i ≥ node.width[level] do # if next step is not too far
            i ← i - node.width[level]  # subtract the current width
            node ← node.next[level]    # traverse forward at the current level
        repeat
    repeat
    return node.value
end function
```

参考链接：<https://en.wikipedia.org/wiki/Skip_list>

