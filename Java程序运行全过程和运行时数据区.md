### 一个JAVA程序编译和执行的整个过程

Java 代码编译是由Java源码编译器来完成，流程图如下所示：

![javac](E:\Files\LearnNotes\img_src\javadebug.gif)

Java字节码的执行是由JVM执行引擎来完成，流程图如下：

![just-in-time](E:\Files\LearnNotes\img_src\jvmdebug.gif)

从上图大概可以了解到Java源码编译器很类似普通编译器，不过普通编译器生成了直接可以在实体机器上运行的机器代码，而Java源码编译器生成的是JVM能够执行的代码。与直接到具体机器上执行的机器代码还有一段距离。这段距离将由JVM来处理（JIT编译器来翻译成机器码）。这也是Java语言跨平台的原因。

JVM是一台抽象的机器，由软件实现，JVM有自己的指令集，和自己控制的内存。Java源程序翻译成字节码后，其实对普通用户来讲就可以把JVM当成物理机来看了，字节码就是这台抽象机器的可以执行的指令。

但是对专业程序员来说，还是必须明白，JVM到真实机器还有一段距离。不同的机器有不同的JVM实现，JVM将字节码再翻译成具体机器匹配的机器码，最终在物理机上执行。JVM以上，是跨平台的。JVM以下是与具体机器相关的。

**[注]：上面这两张图就已经包含的丰富的信息**

----

Java 代码编译和执行的整个过程有三个重要机制：

* Java源码编译机制
* 类加载机制
* 类执行机制



#### Java源码编译机制

Java 源码编译由以下三个过程组成：

-  分析和输入到符号表
- 注解处理
- 语义分析和生成class 文件

#### 类加载机制

JVM的类加载是通过ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图描述:

![javaclassloader](E:\Files\LearnNotes\img_src\jvmclass.gif)

上述过程也叫委派模型。

#### 类执行机制

JVM基于栈的体系结构来执行class字节码。线程创建后会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的执行在方法内的偏移量（此处和JVM Spec不一致），栈中存放一个个栈帧，每个帧对应着每个方法的每次调用，而栈帧又有局部变量区和操作数栈两部分组成，局部变量区存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程产生的中间结果（？？？合理怀疑这句话的正确性）。栈的结构如下图所示：

![stackinfo](E:\Files\LearnNotes\img_src\classrun.gif)

---

### 运行时数据区

Java Virtual Machine 定义了一些在程序执行的时候需要使用的运行时数据区。一些区域随着虚拟机的启动创建，虚拟机的退出而销毁。另一些是随着线程的创建而创建，线程的结束而销毁。

- **PC寄存器：**
  - 当执行非本地方法时：保存当前正在执行的JVM指令的地址
  - 当执行本地方法(native method)时：其保存的值未定义
  
- **虚拟机栈：**
  - 随线程的启动而创建，为线程私有的。栈中保存了方法调用而产生的一个个栈帧，栈内保存方法的局部变量和部分结果。正在执行的方法在栈顶。方法结束栈顶退栈，方法调用另外的方法，会入栈一个新的栈帧，并变为新的当前活跃栈帧。栈内存不必连续。
  
- **堆：**
  - 存放类的实例，为所有线程共享的内存区域，可以不连续分配。
  
- **方法区：**
  - 保存类结构如:运行时常量池，字段，方法数据，方法和构造器的代码。在JVM启动时创建，尽管逻辑上属于堆，但是简单实现一般不在该区进行垃圾回收或压缩。
  - 可固定大小，也可随需求扩展或收缩存储空间，不必连续分配。
  
- **运行常量池：**
  - 运行时常量池是class文件中常量池表在运行期的表示，它包含的各种常量，如数字的字面值(编译器已知)，运行期必须解析的字段引用。
  - 每个运行时常量池都是从方法区中分配的
  - 每个运行时常量池在该类或接口被JVM创建时随之创建
  - 可抛出OutOfMemoryError
  
- **本地方法栈：**
  - 本地方法：用Java语言之外编写的方法
  - 无法加载本地方法或本身不依赖传统堆栈的JVM实现无需提供本地方法栈，如果提供了，则通常创建每个线程时为每个线程分配本地方法栈。



**如下图:**

![JVM-runtime-area](E:\Files\LearnNotes\img_src\JVM-runtime-data-area.webp)
