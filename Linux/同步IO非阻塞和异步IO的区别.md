同步 I/O 配合非阻塞文件描述符（Nonblocking）与异步 I/O 虽然都能避免进程**永久阻塞**，但它们的核心机制、适用场景和编程模型有本质区别。下面从工作流程、阻塞时机、通知方式等维度详细对比：

### 核心区别对比表

| **维度**       | **同步 I/O + 非阻塞（Nonblocking）**                                              | **异步 I/O**                                                           |
| ------------ | -------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| **核心机制**     | 进程主动发起 I/O 操作，若操作未就绪（如无数据可读），立即返回错误（`EAGAIN`/`EWOULDBLOCK`），需进程**主动轮询重试**。 | 进程发起 I/O 操作后立即返回，内核**在后台完成整个 I/O 流程**（包括数据读取 / 写入），完成后通过信号 / 回调通知进程。 |
| **阻塞时机**     | 发起 I/O 时**不阻塞**（因非阻塞标志），但需**主动轮询**（如循环调用 `read`），轮询过程消耗 CPU 资源。            | 发起 I/O 后**完全不阻塞**，进程可做其他任务，无需轮询，CPU 利用率更高。                           |
| **I/O 完成通知** | 无自动通知，进程需通过反复调用 I/O 函数（如 `read`）判断是否完成（轮询）。                                | 内核通过信号、回调函数等**主动通知**进程 I/O 已完成。                                      |
| **数据处理阶段**   | I/O 操作（如从内核拷贝数据到用户空间）由进程**主动触发**（需显式调用 `read`）。                            | 数据处理（如内核到用户空间的拷贝）由内核在后台完成，通知进程时数据已就绪。                                |
| **编程复杂度**    | 需手动处理轮询逻辑（如结合 `select`/`poll` 减少无效轮询），逻辑相对简单。                              | 需处理异步通知、状态同步、错误回调等，逻辑更复杂（如避免回调地狱）。                                   |