## 单例模式

定义： 只存在类的一个实例，并且提供一个全局访问点。

根据这个类的实例的初始化时机，分为懒汉模式和饿汉模式。

在程序启动时就初始化类的唯一实例叫做饿汉模式

程序启动时不初始化类的唯一实例，等到第一次使用这个类的实例时在执行初始化操作。叫做懒汉模式。
也就是将类的唯一实例的初始化工作延后了。这就是懒汉模式。

实现方式(C++11):

饿汉模式： 将这个唯一实例定义为类的静态成员变量，然后静态成员方法返回该静态成员的引用即可。(C++ 中类的静态成员变量在程序启动时就会初始化，且天生线程安全)
懒汉模式： 将这个唯一实例定义为类的成员函数的静态局部变量(static local variable)，然后这个成员函数返回这个静态局部变量的引用即可。
C++ 中函数内的静态局部变量的初始化：静态局部变量在 C++ 中是在“第一次执行到它的定义语句时”初始化的（延迟初始化，lazy initialization），并且 C++11 起保证线程安全。 》》》 这也就实现了单例模式的懒汉模式。

注： C++ 中静态局部变量的内存分配是在程序启动时就已经分配好了，分配在静态存储区。但是初始化工作推迟到第一次定义语句执行的时候。
静态存储区是 .data 段或者 .bss 段。

## 懒汉模式代码

```c
#include <iostream>
using namespace std;

class Singleton {
private:
    Singleton() { cout << "Lazy Singleton created\n"; }

public:
    static Singleton& getInstance() {
        // 懒汉模式
        static Singleton instance; // C++11 保证线程安全的懒加载
        return instance;
    }

    void show() { cout << "Hello from Lazy Singleton\n"; }

    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    cout << "Before using Singleton\n";
    Singleton::getInstance().show();
    cout << "After using Singleton\n";
}

// 笔记： 放在函数内部的静态局部变量的方式就是懒汉模式
//       放在类的静态成员变量的方式就是饿汉模式。
```

### 饿汉模式代码

```c
#include <iostream>
using namespace std;

class Singleton {
private:
    // 放在类的静态成员变量上，是饿汉模式
    static Singleton instance; // 静态成员，在程序启动时创建
    Singleton() { cout << "Eager Singleton created\n"; }

public:
    static Singleton& getInstance() {
        return instance;
    }

    void show() { cout << "Hello from Eager Singleton\n"; }

    // 禁止拷贝和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

// 静态对象定义与初始化
Singleton Singleton::instance;

int main() {
    cout << "before using singleton\n" ;
    Singleton& s1 = Singleton::getInstance();
    Singleton& s2 = Singleton::getInstance();
    cout << &s1 << " == " << &s2 << endl;
}
```