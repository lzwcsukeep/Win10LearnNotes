智能指针也是指针，指向了某个对象，不过相比于原始指针，智能指针在其生命周期走到尽头的时候会自动调用delete释放**堆内存**。

比如用new 获取的指向某个类型某个对象的原始指针 `<type> *raw = new <type> ;`

在raw 指向的对象不需要使用了之后需要手动调用delete raw，来释放raw指向的堆内存。

智能指针可以帮你自动化释放内存的操作，而不需手动调用delete。

智能指针的分类：

**unique_ptr:**

只能有唯一的一个unique_ptr指针指向对象，不能将unique_ptr复制给其他智能指针。

一旦unique_ptr走到生命周期之外，即刻自动调用delete释放内存。

**shared_ptr:**

采用引用计数的方法，来计算同时有多少个shared_ptr指向同一个对象，将shared_ptr复制给另一个shared_ptr会增加该对象的引用计数。当某个shared_ptr走向作用域范围之外，将该对象的引用计数减一，shared_ptr走向作用域之外不会立马调用delete释放内存而是只有引用计数减一之后为0，才释放内存，因此此时表示没有指针引用该对象了。 

**weak_ptr:**

weak_ptr只获取某个对象的引用，而不获取对象的所有权。不获取对象的所有权的意思是将shared_ptr 赋值给weak_ptr不会增加该对象的引用计数。如果指向某对象的所有的shared_ptr都走向的作用域范围之外，该对象会立马调用delete释放内存，即使这时候有weak_ptr指向该对象。weak_ptr在只想保存对象的引用，而不获取对象的所有权时很有用。当然，你可以询问weak_ptr，它所指的对象有没有过期。
