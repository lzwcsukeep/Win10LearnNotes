智能指针也是指针，指向了某个对象，不过相比于原始指针，智能指针在其生命周期走到尽头的时候会自动调用delete释放**堆内存**。

比如用new 获取的指向某个类型某个对象的原始指针 `<type> *raw = new <type> ;`

在raw 指向的对象不需要使用了之后需要手动调用delete raw，来释放raw指向的堆内存。

智能指针可以帮你自动化释放内存的操作，而不需手动调用delete。



智能指针封装了裸指针，专业术语叫做take ownership of the raw pointer。 智能指针还可以share ownership。

只能通过智能指针类型之间赋值 share。

> shared_ptr objects can only share ownership by copying their value: If two shared_ptr are constructed (or [made](https://cplusplus.com/make_shared)) from the same (non-shared_ptr) pointer, they will both be owning the pointer without sharing it, causing potential access problems when one of them releases it (deleting its managed object) and leaving the other pointing to an invalid location.



智能指针的分类：

**unique_ptr:**

只能有唯一的一个unique_ptr指针指向对象，不能将unique_ptr复制给其他智能指针。

一旦unique_ptr走到生命周期之外，即刻自动调用delete释放内存。

**shared_ptr:**

采用引用计数的方法，来计算同时有多少个shared_ptr指向同一个对象，将shared_ptr复制给另一个shared_ptr会增加该对象的引用计数。当某个shared_ptr走向作用域范围之外，或者shared_ptr的值通过赋值运算被改变，或者通过`reset`函数,会将该对象的引用计数减一，shared_ptr走向作用域之外不会立马调用delete释放内存而是只有引用计数减一之后为0，才释放内存，因此此时表示没有指针引用该对象了。 

**weak_ptr:**

weak_ptr只获取某个对象的引用，而不获取对象的所有权。不获取对象的所有权的意思是将shared_ptr 赋值给weak_ptr不会增加该对象的引用计数。如果指向某对象的所有的shared_ptr都走向的作用域范围之外，该对象会立马调用delete释放内存，即使这时候有weak_ptr指向该对象。weak_ptr在只想保存对象的引用，而不获取对象的所有权时很有用。当然，你可以询问weak_ptr，它所指的对象有没有过期。
