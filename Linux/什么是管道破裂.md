“管道破裂”（Broken Pipe）是 Unix/Linux 系统中与管道（包括匿名管道和有名管道 FIFO）相关的一种常见错误，对应的错误码为 `EPIPE`，通常发生在**写端向管道写入数据时，读端已关闭**的场景。下面详细解释：

### 核心原因：管道读写端不匹配

管道的正常工作依赖 “读端” 和 “写端” 的同时存在：

- 写端（进程）负责向管道写入数据。
- 读端（进程）负责从管道读取数据。

当**读端提前关闭**（如读进程退出、主动关闭文件描述符），而写端仍在尝试写入数据时，内核会认为 “写入的数据已无意义”（没有进程会读取），此时会向写进程发送 `SIGPIPE` 信号，并返回 `EPIPE` 错误（若写进程捕获了 `SIGPIPE` 信号）。

### 具体场景示例

1. **简单管道通信**：进程 A（写端）通过管道向进程 B（读端）发送数据。若进程 B 意外崩溃（或主动 `close` 读端），进程 A 继续调用 `write` 写入数据时：
   
   - 内核检测到读端已关闭，向进程 A 发送 `SIGPIPE` 信号（默认行为是终止进程 A）。
   - 若进程 A 捕获了 `SIGPIPE` 信号，则 `write` 调用会返回 `-1`，并设置 `errno = EPIPE`（“管道破裂”）。

2. **使用 `popen` 的场景**：若父进程通过 `popen("command", "w")` 向子进程写入数据，而子进程（`command`）提前退出（读端关闭），父进程继续 `fprintf` 时会触发 `EPIPE` 错误。

### `SIGPIPE` 信号与 `EPIPE` 错误的关系

- **`SIGPIPE` 信号**：内核在检测到 “写端向已关闭的读端写入” 时，会自动向写进程发送此信号。默认情况下，进程收到 `SIGPIPE` 会直接终止（这就是为什么有时程序会突然退出，且提示 “Broken pipe”）。
- **`EPIPE` 错误**：若写进程通过 `signal(SIGPIPE, SIG_IGN)` 忽略了 `SIGPIPE` 信号，或在信号处理函数中返回，则 `write`/`fwrite` 等写入操作会返回 `-1`，并将 `errno` 设为 `EPIPE`，供进程手动处理错误。

### 如何避免或处理 “管道破裂”

1. **确保读端正常运行**：设计程序时，保证读端在写端完成数据传输前不提前退出（如通过同步机制、信号通知等）。

2. **捕获 `SIGPIPE` 信号**：忽略或处理 `SIGPIPE`，避免进程被意外终止，同时通过 `EPIPE` 错误码判断管道状态：

   运行

```c
#include <signal.h>
#include <stdio.h>
#include <errno.h>

int main() {
   // 忽略 SIGPIPE 信号，避免进程被终止
   signal(SIGPIPE, SIG_IGN);

   // 假设 fp 是通过 popen 打开的写端
   FILE *fp = popen("some_command", "w");
   if (fp == NULL) { /* 错误处理 */ }

   // 尝试写入数据
   if (fprintf(fp, "data") < 0) {
       if (errno == EPIPE) {
           printf("管道破裂：读端已关闭\n");
       }
   }

   pclose(fp);
   return 0;
}
```

3. **检查管道状态**：在写入数据前，可通过 `select`/`poll` 等 I/O 多路复用机制检查管道是否可写，间接判断读端是否存在（但无法完全避免，因为读端可能在检查后、写入前关闭）。

### 总结

“管道破裂”（`EPIPE`）是由于**写端向已关闭的读端写入数据**导致的错误，内核会通过 `SIGPIPE` 信号通知写进程。处理方式通常是忽略 `SIGPIPE` 并捕获 `EPIPE` 错误，以优雅地处理读端意外退出的情况。这一机制确保了管道通信的合理性 —— 避免写入无人读取的数据。
